-- =========================================
-- ClickModel.AI - Complete Database Schema
-- Based on Cinthiamed authentication system
-- =========================================

-- Enable required extensions
CREATE EXTENSION IF NOT EXISTS "uuid-ossp";
CREATE EXTENSION IF NOT EXISTS "pgcrypto";

-- =========================================
-- 1. USERS & AUTHENTICATION TABLES
-- =========================================

-- USERS: Main user table (replaces profiles, links to auth.users)
CREATE TABLE IF NOT EXISTS public.users (
    id UUID PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
    name VARCHAR(255) NOT NULL,
    email VARCHAR(255) UNIQUE NOT NULL,
    avatar_url TEXT,
    google_id VARCHAR(255) UNIQUE,
    email_verified BOOLEAN DEFAULT FALSE,
    verification_token VARCHAR(255) UNIQUE,
    verification_token_expires TIMESTAMP WITH TIME ZONE,
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL,
    last_login TIMESTAMP WITH TIME ZONE
);

-- SESSIONS: JWT token management
CREATE TABLE IF NOT EXISTS public.sessions (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    user_id UUID REFERENCES public.users(id) ON DELETE CASCADE NOT NULL,
    token VARCHAR(500) NOT NULL UNIQUE,
    expires_at TIMESTAMP WITH TIME ZONE NOT NULL,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL,
    ip_address VARCHAR(45),
    user_agent TEXT
);

-- PASSWORD_RESETS: Password recovery tokens
CREATE TABLE IF NOT EXISTS public.password_resets (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    user_id UUID REFERENCES public.users(id) ON DELETE CASCADE NOT NULL,
    token VARCHAR(500) NOT NULL UNIQUE,
    expires_at TIMESTAMP WITH TIME ZONE NOT NULL,
    used BOOLEAN DEFAULT FALSE,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL
);

-- =========================================
-- 2. CREDITS & SUBSCRIPTION SYSTEM
-- =========================================

-- USER_CREDITS: Credits balance and subscription info
CREATE TABLE IF NOT EXISTS public.user_credits (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    user_id UUID REFERENCES public.users(id) ON DELETE CASCADE NOT NULL UNIQUE,
    credits INTEGER DEFAULT 5 NOT NULL CHECK (credits >= 0),

    -- Subscription info
    subscription_tier VARCHAR(20) DEFAULT 'free' NOT NULL CHECK (subscription_tier IN ('free', 'starter', 'pro', 'agency')),
    subscription_status VARCHAR(20) DEFAULT 'inactive' CHECK (subscription_status IN ('active', 'inactive', 'cancelled', 'past_due')),
    subscription_start_date TIMESTAMP WITH TIME ZONE,
    subscription_end_date TIMESTAMP WITH TIME ZONE,
    subscription_renewal_date TIMESTAMP WITH TIME ZONE,

    -- Credits allocation per plan
    monthly_credit_limit INTEGER DEFAULT 5 NOT NULL, -- Credits to reset each month
    bonus_credits INTEGER DEFAULT 0 NOT NULL CHECK (bonus_credits >= 0), -- Extra credits (don't expire)

    -- Stripe integration
    stripe_customer_id TEXT UNIQUE,
    stripe_subscription_id TEXT UNIQUE,

    created_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL
);

-- SUBSCRIPTION_PLANS: Plan configurations
CREATE TABLE IF NOT EXISTS public.subscription_plans (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    tier VARCHAR(20) UNIQUE NOT NULL CHECK (tier IN ('free', 'starter', 'pro', 'agency')),
    name VARCHAR(100) NOT NULL,
    description TEXT,
    price_brl INTEGER NOT NULL, -- Price in cents (R$ 97.00 = 9700)
    monthly_credits INTEGER NOT NULL,
    features JSONB, -- Array of features: ["50 Fotos/mês", "Modelos Padrão", ...]
    is_active BOOLEAN DEFAULT TRUE,
    stripe_price_id TEXT, -- Stripe Price ID for billing
    created_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL
);

-- CREDIT_TRANSACTIONS: Audit log for all credit changes
CREATE TABLE IF NOT EXISTS public.credit_transactions (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    user_id UUID REFERENCES public.users(id) ON DELETE CASCADE NOT NULL,
    amount INTEGER NOT NULL, -- Positive for additions, negative for usage
    balance_after INTEGER NOT NULL, -- Balance after transaction
    transaction_type VARCHAR(30) NOT NULL CHECK (transaction_type IN (
        'welcome_bonus',
        'subscription_renewal',
        'purchase',
        'generation_usage',
        'bonus',
        'refund',
        'admin_adjustment'
    )),
    description TEXT,

    -- Reference IDs
    generation_id BIGINT, -- Links to generations table
    stripe_payment_id TEXT,

    created_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL
);

-- =========================================
-- 3. GENERATIONS & CONTENT
-- =========================================

-- GENERATIONS: AI generation history
CREATE TABLE IF NOT EXISTS public.generations (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    user_id UUID REFERENCES public.users(id) ON DELETE CASCADE NOT NULL,

    -- Image URLs
    garment_image_url TEXT NOT NULL,
    model_image_url TEXT,
    result_image_url TEXT,

    -- Generation params
    clothing_type VARCHAR(20) CHECK (clothing_type IN ('tops', 'bottoms', 'one-pieces')),
    prompt TEXT,

    -- Status tracking
    status VARCHAR(20) DEFAULT 'processing' CHECK (status IN ('processing', 'completed', 'failed')),
    error_message TEXT,

    -- Costs
    credits_used INTEGER DEFAULT 1 NOT NULL,

    -- AI Provider info
    fal_request_id TEXT,
    generation_time_ms INTEGER,

    created_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL,
    completed_at TIMESTAMP WITH TIME ZONE
);

-- =========================================
-- 4. INDEXES FOR PERFORMANCE
-- =========================================

-- Users
CREATE INDEX IF NOT EXISTS idx_users_email ON public.users(email);
CREATE INDEX IF NOT EXISTS idx_users_google_id ON public.users(google_id);
CREATE INDEX IF NOT EXISTS idx_users_verification_token ON public.users(verification_token);

-- Sessions
CREATE INDEX IF NOT EXISTS idx_sessions_token ON public.sessions(token);
CREATE INDEX IF NOT EXISTS idx_sessions_user_id ON public.sessions(user_id);
CREATE INDEX IF NOT EXISTS idx_sessions_expires_at ON public.sessions(expires_at);

-- Password Resets
CREATE INDEX IF NOT EXISTS idx_password_resets_token ON public.password_resets(token);
CREATE INDEX IF NOT EXISTS idx_password_resets_user_id ON public.password_resets(user_id);

-- User Credits
CREATE INDEX IF NOT EXISTS idx_user_credits_user_id ON public.user_credits(user_id);
CREATE INDEX IF NOT EXISTS idx_user_credits_stripe_customer ON public.user_credits(stripe_customer_id);
CREATE INDEX IF NOT EXISTS idx_user_credits_renewal_date ON public.user_credits(subscription_renewal_date);

-- Credit Transactions
CREATE INDEX IF NOT EXISTS idx_credit_transactions_user_id ON public.credit_transactions(user_id);
CREATE INDEX IF NOT EXISTS idx_credit_transactions_created_at ON public.credit_transactions(created_at);
CREATE INDEX IF NOT EXISTS idx_credit_transactions_type ON public.credit_transactions(transaction_type);

-- Generations
CREATE INDEX IF NOT EXISTS idx_generations_user_id ON public.generations(user_id);
CREATE INDEX IF NOT EXISTS idx_generations_status ON public.generations(status);
CREATE INDEX IF NOT EXISTS idx_generations_created_at ON public.generations(created_at DESC);

-- =========================================
-- 5. ROW LEVEL SECURITY (RLS)
-- =========================================

ALTER TABLE public.users ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.sessions ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.password_resets ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.user_credits ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.subscription_plans ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.credit_transactions ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.generations ENABLE ROW LEVEL SECURITY;

-- Drop existing policies if they exist
DROP POLICY IF EXISTS "Users can view their own profile" ON public.users;
DROP POLICY IF EXISTS "Users can update their own profile" ON public.users;
DROP POLICY IF EXISTS "Users can view their own sessions" ON public.sessions;
DROP POLICY IF EXISTS "Users can delete their own sessions" ON public.sessions;
DROP POLICY IF EXISTS "Users can view their own credits" ON public.user_credits;
DROP POLICY IF EXISTS "Anyone can view active subscription plans" ON public.subscription_plans;
DROP POLICY IF EXISTS "Users can view their own transactions" ON public.credit_transactions;
DROP POLICY IF EXISTS "Users can view their own generations" ON public.generations;
DROP POLICY IF EXISTS "Users can insert their own generations" ON public.generations;
DROP POLICY IF EXISTS "Users can update their own generations" ON public.generations;

-- USERS Policies
CREATE POLICY "Users can view their own profile"
    ON public.users FOR SELECT
    USING (auth.uid() = id);

CREATE POLICY "Users can update their own profile"
    ON public.users FOR UPDATE
    USING (auth.uid() = id);

-- SESSIONS Policies
CREATE POLICY "Users can view their own sessions"
    ON public.sessions FOR SELECT
    USING (auth.uid() = user_id);

CREATE POLICY "Users can delete their own sessions"
    ON public.sessions FOR DELETE
    USING (auth.uid() = user_id);

-- USER_CREDITS Policies
CREATE POLICY "Users can view their own credits"
    ON public.user_credits FOR SELECT
    USING (auth.uid() = user_id);

-- SUBSCRIPTION_PLANS Policies (Public read)
CREATE POLICY "Anyone can view active subscription plans"
    ON public.subscription_plans FOR SELECT
    USING (is_active = true);

-- CREDIT_TRANSACTIONS Policies
CREATE POLICY "Users can view their own transactions"
    ON public.credit_transactions FOR SELECT
    USING (auth.uid() = user_id);

-- GENERATIONS Policies
CREATE POLICY "Users can view their own generations"
    ON public.generations FOR SELECT
    USING (auth.uid() = user_id);

CREATE POLICY "Users can insert their own generations"
    ON public.generations FOR INSERT
    WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update their own generations"
    ON public.generations FOR UPDATE
    USING (auth.uid() = user_id);

-- =========================================
-- 6. STORAGE BUCKETS & POLICIES
-- =========================================

-- Create generations bucket (public access for viewing)
INSERT INTO storage.buckets (id, name, public)
VALUES ('generations', 'generations', true)
ON CONFLICT (id) DO NOTHING;

-- Drop existing storage policies if they exist
DROP POLICY IF EXISTS "Authenticated users can upload to generations" ON storage.objects;
DROP POLICY IF EXISTS "Users can view generation images" ON storage.objects;
DROP POLICY IF EXISTS "Users can delete their own uploads" ON storage.objects;

-- Storage policies
CREATE POLICY "Authenticated users can upload to generations"
    ON storage.objects FOR INSERT
    WITH CHECK (bucket_id = 'generations' AND auth.role() = 'authenticated');

CREATE POLICY "Users can view generation images"
    ON storage.objects FOR SELECT
    USING (bucket_id = 'generations');

CREATE POLICY "Users can delete their own uploads"
    ON storage.objects FOR DELETE
    USING (bucket_id = 'generations' AND auth.uid()::text = (storage.foldername(name))[1]);

-- =========================================
-- 7. FUNCTIONS & TRIGGERS
-- =========================================

-- Function: Auto-create user and credits on signup
CREATE OR REPLACE FUNCTION public.handle_new_user()
RETURNS TRIGGER AS $$
BEGIN
    -- 1. Create user record
    INSERT INTO public.users (id, email, name, avatar_url, google_id, email_verified)
    VALUES (
        NEW.id,
        NEW.email,
        COALESCE(NEW.raw_user_meta_data->>'full_name', NEW.raw_user_meta_data->>'name', 'User'),
        NEW.raw_user_meta_data->>'avatar_url',
        NEW.raw_user_meta_data->>'provider_id',
        CASE WHEN NEW.raw_user_meta_data->>'email_verified' = 'true' THEN true ELSE false END
    );

    -- 2. Create credit account with welcome bonus
    INSERT INTO public.user_credits (user_id, credits, monthly_credit_limit, subscription_tier)
    VALUES (NEW.id, 5, 5, 'free');

    -- 3. Log welcome bonus transaction
    INSERT INTO public.credit_transactions (user_id, amount, balance_after, transaction_type, description)
    VALUES (NEW.id, 5, 5, 'welcome_bonus', 'Welcome to ClickModel.AI! 5 free credits');

    RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Trigger: Run handle_new_user on auth.users insert
DROP TRIGGER IF EXISTS on_auth_user_created ON auth.users;
CREATE TRIGGER on_auth_user_created
    AFTER INSERT ON auth.users
    FOR EACH ROW EXECUTE FUNCTION public.handle_new_user();

-- Function: Auto-update updated_at timestamp
CREATE OR REPLACE FUNCTION public.handle_updated_at()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Apply updated_at trigger to relevant tables
DROP TRIGGER IF EXISTS set_updated_at_users ON public.users;
CREATE TRIGGER set_updated_at_users
    BEFORE UPDATE ON public.users
    FOR EACH ROW EXECUTE FUNCTION public.handle_updated_at();

DROP TRIGGER IF EXISTS set_updated_at_user_credits ON public.user_credits;
CREATE TRIGGER set_updated_at_user_credits
    BEFORE UPDATE ON public.user_credits
    FOR EACH ROW EXECUTE FUNCTION public.handle_updated_at();

DROP TRIGGER IF EXISTS set_updated_at_subscription_plans ON public.subscription_plans;
CREATE TRIGGER set_updated_at_subscription_plans
    BEFORE UPDATE ON public.subscription_plans
    FOR EACH ROW EXECUTE FUNCTION public.handle_updated_at();

-- =========================================
-- 8. CREDIT MANAGEMENT FUNCTIONS (RPC)
-- =========================================

-- Function: Deduct credits atomically
CREATE OR REPLACE FUNCTION public.deduct_credits(
    credits_to_deduct INTEGER,
    generation_description TEXT DEFAULT 'Image generation',
    generation_ref_id BIGINT DEFAULT NULL
)
RETURNS JSON AS $$
DECLARE
    v_user_id UUID;
    v_current_credits INTEGER;
    v_bonus_credits INTEGER;
    v_new_balance INTEGER;
BEGIN
    v_user_id := auth.uid();

    IF v_user_id IS NULL THEN
        RETURN json_build_object('success', false, 'error', 'Not authenticated');
    END IF;

    -- Get current credits (with row lock)
    SELECT credits, bonus_credits
    INTO v_current_credits, v_bonus_credits
    FROM public.user_credits
    WHERE user_id = v_user_id
    FOR UPDATE;

    -- Check if user has enough credits
    IF v_current_credits < credits_to_deduct THEN
        RETURN json_build_object(
            'success', false,
            'error', 'Insufficient credits',
            'current_credits', v_current_credits,
            'required', credits_to_deduct
        );
    END IF;

    -- Deduct credits (prioritize regular credits before bonus)
    UPDATE public.user_credits
    SET credits = credits - credits_to_deduct
    WHERE user_id = v_user_id
    RETURNING credits INTO v_new_balance;

    -- Log transaction
    INSERT INTO public.credit_transactions (
        user_id,
        amount,
        balance_after,
        transaction_type,
        description,
        generation_id
    )
    VALUES (
        v_user_id,
        -credits_to_deduct,
        v_new_balance,
        'generation_usage',
        generation_description,
        generation_ref_id
    );

    RETURN json_build_object(
        'success', true,
        'credits_deducted', credits_to_deduct,
        'new_balance', v_new_balance
    );
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Function: Add credits (for purchases, bonuses, refunds)
CREATE OR REPLACE FUNCTION public.add_credits(
    credits_to_add INTEGER,
    transaction_type_param VARCHAR(30),
    description_param TEXT DEFAULT NULL,
    stripe_payment_id_param TEXT DEFAULT NULL
)
RETURNS JSON AS $$
DECLARE
    v_user_id UUID;
    v_new_balance INTEGER;
BEGIN
    v_user_id := auth.uid();

    IF v_user_id IS NULL THEN
        RETURN json_build_object('success', false, 'error', 'Not authenticated');
    END IF;

    -- Add credits
    UPDATE public.user_credits
    SET credits = credits + credits_to_add
    WHERE user_id = v_user_id
    RETURNING credits INTO v_new_balance;

    -- Log transaction
    INSERT INTO public.credit_transactions (
        user_id,
        amount,
        balance_after,
        transaction_type,
        description,
        stripe_payment_id
    )
    VALUES (
        v_user_id,
        credits_to_add,
        v_new_balance,
        transaction_type_param,
        description_param,
        stripe_payment_id_param
    );

    RETURN json_build_object(
        'success', true,
        'credits_added', credits_to_add,
        'new_balance', v_new_balance
    );
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Function: Renew subscription credits (called monthly)
CREATE OR REPLACE FUNCTION public.renew_subscription_credits()
RETURNS JSON AS $$
DECLARE
    v_user_id UUID;
    v_monthly_limit INTEGER;
    v_new_renewal_date TIMESTAMP WITH TIME ZONE;
BEGIN
    v_user_id := auth.uid();

    IF v_user_id IS NULL THEN
        RETURN json_build_object('success', false, 'error', 'Not authenticated');
    END IF;

    -- Get monthly credit limit
    SELECT monthly_credit_limit
    INTO v_monthly_limit
    FROM public.user_credits
    WHERE user_id = v_user_id
    AND subscription_status = 'active';

    IF v_monthly_limit IS NULL THEN
        RETURN json_build_object('success', false, 'error', 'No active subscription');
    END IF;

    -- Reset credits to monthly limit (bonus credits are preserved)
    v_new_renewal_date := NOW() + INTERVAL '1 month';

    UPDATE public.user_credits
    SET
        credits = v_monthly_limit,
        subscription_renewal_date = v_new_renewal_date,
        updated_at = NOW()
    WHERE user_id = v_user_id;

    -- Log renewal transaction
    INSERT INTO public.credit_transactions (
        user_id,
        amount,
        balance_after,
        transaction_type,
        description
    )
    VALUES (
        v_user_id,
        v_monthly_limit,
        v_monthly_limit,
        'subscription_renewal',
        'Monthly subscription credits renewed'
    );

    RETURN json_build_object(
        'success', true,
        'credits_renewed', v_monthly_limit,
        'next_renewal', v_new_renewal_date
    );
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Function: Clean expired sessions (maintenance)
CREATE OR REPLACE FUNCTION public.clean_expired_sessions()
RETURNS INTEGER AS $$
DECLARE
    deleted_count INTEGER;
BEGIN
    DELETE FROM public.sessions
    WHERE expires_at < NOW();

    GET DIAGNOSTICS deleted_count = ROW_COUNT;
    RETURN deleted_count;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Function: Clean expired password reset tokens (maintenance)
CREATE OR REPLACE FUNCTION public.clean_expired_password_resets()
RETURNS INTEGER AS $$
DECLARE
    deleted_count INTEGER;
BEGIN
    DELETE FROM public.password_resets
    WHERE expires_at < NOW() OR used = true;

    GET DIAGNOSTICS deleted_count = ROW_COUNT;
    RETURN deleted_count;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- =========================================
-- 9. INITIAL DATA - SUBSCRIPTION PLANS
-- =========================================

INSERT INTO public.subscription_plans (tier, name, description, price_brl, monthly_credits, features, stripe_price_id, is_active)
VALUES
    ('free', 'Free', 'Teste gratuito', 0, 5,
     '["5 Gerações gratuitas", "Modelos básicos", "Qualidade HD"]'::jsonb,
     NULL, true),

    ('starter', 'Starter', 'Perfeito para começar a testar', 9700, 50,
     '["50 Fotos geradas/mês", "Modelos Padrão", "Qualidade 4K", "Suporte por Email"]'::jsonb,
     NULL, true),

    ('pro', 'Pro', 'Para lojas que precisam de escala', 29700, 300,
     '["300 Fotos geradas/mês", "Todos os Modelos Premium", "Prioridade na fila", "Suporte Prioritário"]'::jsonb,
     NULL, true),

    ('agency', 'Agency', 'Volume alto e API dedicada', 49700, 1000,
     '["1000 Fotos geradas/mês", "API Access", "Gerente de Conta", "Modelo Personalizado"]'::jsonb,
     NULL, true)
ON CONFLICT (tier) DO UPDATE SET
    name = EXCLUDED.name,
    description = EXCLUDED.description,
    price_brl = EXCLUDED.price_brl,
    monthly_credits = EXCLUDED.monthly_credits,
    features = EXCLUDED.features,
    updated_at = NOW();

-- =========================================
-- 10. SCHEDULED JOBS (Using pg_cron extension)
-- =========================================
-- Note: pg_cron must be enabled by Supabase admin
-- These are example cron jobs for maintenance

-- Clean expired sessions daily at 3 AM UTC
-- SELECT cron.schedule('clean-expired-sessions', '0 3 * * *', 'SELECT public.clean_expired_sessions()');

-- Clean expired password resets daily at 3:30 AM UTC
-- SELECT cron.schedule('clean-expired-resets', '30 3 * * *', 'SELECT public.clean_expired_password_resets()');

-- =========================================
-- SCHEMA COMPLETE
-- =========================================

COMMENT ON TABLE public.users IS 'User accounts and authentication data';
COMMENT ON TABLE public.sessions IS 'JWT session tokens for authentication';
COMMENT ON TABLE public.password_resets IS 'Password recovery tokens';
COMMENT ON TABLE public.user_credits IS 'User credit balances and subscription info';
COMMENT ON TABLE public.subscription_plans IS 'Available subscription plan configurations';
COMMENT ON TABLE public.credit_transactions IS 'Audit log of all credit changes';
COMMENT ON TABLE public.generations IS 'AI image generation history';
